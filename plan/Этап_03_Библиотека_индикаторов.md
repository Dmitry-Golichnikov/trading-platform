# Этап 03: Библиотека технических индикаторов

## Цель этапа
Реализовать библиотеку каузальных технических индикаторов для построения признаков.

## Зависимости
- Этап 00, 01, 02

## Описание задач

### 1. Структура модуля

```
src/features/indicators/
├── __init__.py
├── base.py                       # Базовый класс Indicator
├── trend/                        # Трендовые индикаторы
│   ├── sma.py, ema.py, wma.py
│   ├── macd.py
│   ├── parabolic_sar.py
│   └── ichimoku.py
├── momentum/                     # Моментум индикаторы
│   ├── rsi.py
│   ├── stochastic.py
│   ├── stochastic_rsi.py
│   ├── cci.py
│   └── williams_r.py
├── volatility/                   # Волатильность
│   ├── atr.py
│   ├── bollinger_bands.py
│   ├── keltner_channels.py
│   └── donchian_channels.py
├── volume/                       # Объёмные индикаторы
│   ├── obv.py
│   ├── vwap.py
│   ├── mfi.py
│   ├── chaikin_mf.py
│   └── volume_profile.py
├── advanced/                     # Продвинутые
│   ├── adx.py
│   ├── elder_force.py
│   ├── trix.py
│   ├── dpo.py
│   ├── fdi.py
│   └── nadaraya_watson.py
└── registry.py                   # Реестр индикаторов
```

### 2. Базовый класс (base.py)

```python
class Indicator(ABC):
    """Базовый класс для технических индикаторов"""

    def __init__(self, **params):
        self.params = params
        self.validate_params()

    @abstractmethod
    def calculate(self, data: pd.DataFrame) -> pd.DataFrame:
        """Рассчитать индикатор. Должен быть каузальным!"""
        pass

    @abstractmethod
    def get_required_columns(self) -> list[str]:
        """Необходимые колонки для расчёта"""
        pass

    @abstractmethod
    def get_lookback_period(self) -> int:
        """Количество баров для warm-up"""
        pass

    def validate_params(self) -> None:
        """Валидация параметров"""
        pass

    @property
    def name(self) -> str:
        """Имя индикатора для колонок"""
        return self.__class__.__name__
```

### 3. Индикаторы по категориям

**Трендовые (docs/indicators/ есть спецификации):**
- SMA, EMA, WMA - скользящие средние
- MACD - Moving Average Convergence Divergence
- Parabolic SAR - stop and reverse
- Ichimoku Cloud - все 5 линий

**Моментум:**
- RSI - Relative Strength Index
- Stochastic Oscillator
- Stochastic RSI
- CCI - Commodity Channel Index
- Williams %R

**Волатильность:**
- ATR - Average True Range
- Bollinger Bands (upper, middle, lower)
- Keltner Channels
- Donchian Channels

**Объёмные:**
- OBV - On Balance Volume
- VWAP - Volume Weighted Average Price
- MFI - Money Flow Index
- Chaikin Money Flow
- Volume Profile, Horizontal Volume

**Продвинутые:**
- ADX - Average Directional Index
- Elder Force Index
- TRIX - Triple Exponential Average
- DPO - Detrended Price Oscillator
- FDI - Fractal Dimension Index
- Nadaraya-Watson Envelope

### 4. Требования к реализации

**Каузальность (критично!):**
- Индикатор в момент t использует только данные до t включительно
- Нет look-ahead bias
- Проверка: shift test (сдвиг данных не меняет индикатор на старых точках)

**Производительность:**
- Векторизация с numpy/pandas
- Избегать циклов где возможно
- Использовать numba для сложных индикаторов
- Кэширование промежуточных результатов

**API:**
```python
# Использование
sma = SMA(window=20)
result = sma.calculate(data)
# result - DataFrame с колонкой 'SMA_20'

macd = MACD(fast=12, slow=26, signal=9)
result = macd.calculate(data)
# result - DataFrame с колонками 'MACD', 'MACD_signal', 'MACD_hist'
```

**Обработка NaN:**
- Первые N баров (warm-up period) = NaN
- Не propagate NaN без необходимости
- Документировать warm-up period

### 5. Реестр индикаторов (registry.py)

```python
class IndicatorRegistry:
    """Централизованный реестр всех индикаторов"""

    _indicators: dict[str, Type[Indicator]] = {}

    @classmethod
    def register(cls, name: str):
        """Декоратор для регистрации индикатора"""
        def decorator(indicator_class):
            cls._indicators[name] = indicator_class
            return indicator_class
        return decorator

    @classmethod
    def get(cls, name: str, **params) -> Indicator:
        """Получить экземпляр индикатора по имени"""
        if name not in cls._indicators:
            raise ValueError(f"Unknown indicator: {name}")
        return cls._indicators[name](**params)

    @classmethod
    def list_all(cls) -> list[str]:
        """Список всех зарегистрированных индикаторов"""
        return list(cls._indicators.keys())
```

### 6. Валидация каузальности

**src/features/indicators/validation.py:**

```python
def validate_causality(indicator: Indicator, test_data: pd.DataFrame) -> bool:
    """
    Проверить что индикатор каузальный

    Метод: добавляем будущие данные и проверяем что
    прошлые значения индикатора не изменились
    """
    # Рассчитать на исходных данных
    result1 = indicator.calculate(test_data)

    # Добавить будущие данные
    extended_data = append_future_bars(test_data, n=10)
    result2 = indicator.calculate(extended_data)

    # Сравнить на overlap period
    overlap = result2.iloc[:len(result1)]
    is_causal = np.allclose(result1.values, overlap.values, rtol=1e-5, atol=1e-8, equal_nan=True)

    return is_causal
```

### 7. Тестирование

**tests/unit/features/indicators/:**
- test_base.py - базовый класс
- test_sma.py, test_ema.py, test_rsi.py и т.д. - каждый индикатор
- test_causality.py - проверка каузальности всех индикаторов
- test_performance.py - бенчмарки

**Структура теста индикатора:**
```python
def test_sma_known_values():
    """Проверка на известных значениях"""
    data = create_test_data([1,2,3,4,5,6,7,8,9,10])
    sma = SMA(window=3)
    result = sma.calculate(data)

    # SMA(3) для [1,2,3] = 2.0
    assert result['SMA_3'].iloc[2] == pytest.approx(2.0)
    # SMA(3) для [4,5,6] = 5.0
    assert result['SMA_3'].iloc[5] == pytest.approx(5.0)

def test_sma_causality():
    """Проверка каузальности"""
    data = generate_random_ohlcv(1000)
    sma = SMA(window=20)
    assert validate_causality(sma, data)
```

### 8. Документация индикаторов

Для каждого индикатора:
- Формула расчёта
- Параметры и их значения по умолчанию
- Интерпретация значений
- Примеры использования
- Ссылки на источники

## Критерии проверки готовности

### Обязательные:
- [ ] Все индикаторы из technical_spec.md реализованы
- [ ] Базовый класс Indicator реализован
- [ ] IndicatorRegistry работает
- [ ] Все индикаторы каузальные (проверено тестами)
- [ ] API единообразный
- [ ] Производительность: расчёт на 10K барах < 1 сек для каждого индикатора
- [ ] Документация всех индикаторов

### Тесты:
- [ ] Unit тесты для каждого индикатора (known values)
- [ ] Тесты каузальности для всех
- [ ] Бенчмарки производительности
- [ ] Edge cases (пустые данные, все NaN, constant prices)

## Промпты для реализации

### Промпт 1: Базовые классы и простые индикаторы
```
Реализуй базовую инфраструктуру индикаторов:

1. src/features/indicators/base.py - Indicator абстрактный класс
2. src/features/indicators/registry.py - IndicatorRegistry
3. src/features/indicators/validation.py - validate_causality()

Затем реализуй простые индикаторы:
- src/features/indicators/trend/sma.py - Simple Moving Average
- src/features/indicators/trend/ema.py - Exponential Moving Average
- src/features/indicators/trend/wma.py - Weighted Moving Average

Используй спецификации из docs/indicators/.
Добавь docstrings с формулами.
Векторизуй операции.
```

### Промпт 2-6: Остальные категории индикаторов
```
Реализуй индикаторы категории [trend/momentum/volatility/volume/advanced]:
[список индикаторов]

Для каждого:
- Наследование от Indicator
- Регистрация в IndicatorRegistry
- Каузальная реализация
- Обработка NaN
- Docstrings с формулами
- Примеры в docstrings

Используй спецификации из docs/indicators/.
```

### Промпт 7: Тесты
```
Создай тесты для индикаторов:

tests/unit/features/indicators/:
- test_каждый_индикатор.py с:
  * test_known_values - проверка на известных данных
  * test_causality - проверка каузальности
  * test_nan_handling - обработка NaN
  * test_edge_cases - граничные случаи

tests/performance/:
- test_indicator_performance.py - бенчмарки

Используй pytest, fixtures для тестовых данных.
```

## Важные замечания

### Каузальность:
Это критично! Все индикаторы должны быть проверены на каузальность.

### Производительность:
- Используйте pandas rolling, expanding
- Для сложных индикаторов - numba
- Профилируйте перед оптимизацией

### Совместимость с TA-Lib:
Если возможно, сверьте результаты с TA-Lib для валидации корректности.

### NaN значения:
Документируйте warm-up period для каждого индикатора.

## Следующий этап
[Этап 04: Генерация признаков](Этап_04_Генерация_признаков.md)
