# Этап 05: Модуль разметки таргетов

## Цель
Реализовать систему генерации таргетов: horizon, triple barrier, кастомные правила.

## Зависимости
Этапы 00-04

## Структура

```
src/labeling/
├── base.py                       # BaseLabeler
├── methods/                      # Методы разметки
│   ├── horizon.py                # Fixed/adaptive horizon
│   ├── triple_barrier.py         # Triple barrier method
│   ├── custom_rules.py           # Кастомные правила
│   └── regression_targets.py     # Regression таргеты
├── filters/                      # Постфильтры
│   ├── smoothing.py              # Сглаживание
│   ├── sequence_filter.py        # Минимальная длина последовательностей
│   ├── majority_vote.py          # Majority vote
│   └── danger_zones.py           # Опасные зоны
├── balancing/                    # Балансировка классов
│   ├── weights.py                # Class weights
│   ├── sampling.py               # Over/undersampling
│   └── sequence_weights.py       # Sequence-aware weighting
└── metadata.py                   # Метаданные разметки
```

## Основные компоненты

### 1. Методы разметки

**Horizon labeling:**
```python
class HorizonLabeler(BaseLabeler):
    """Fixed или adaptive horizon"""

    def __init__(
        self,
        horizon: int | str = 20,  # Фиксированный или 'adaptive'
        direction: str = 'long+short',  # 'long', 'short', 'long+short'
        threshold_pct: float = 0.01,  # 1% для long/short
        adaptive_method: str = 'atr'  # 'atr', 'volatility', 'custom'
    ):
        ...
```

**Triple Barrier:**
```python
class TripleBarrierLabeler(BaseLabeler):
    """Triple barrier метод (Lopez de Prado)"""

    def __init__(
        self,
        upper_barrier: float | str = 0.02,  # % или 'atr'
        lower_barrier: float | str = 0.02,
        time_barrier: int = 20,  # bars
        direction: str = 'long+short',
        min_return: float = 0.0  # Минимальный return для учёта
    ):
        ...
```

Возвращает:
- label: int (-1, 0, 1) или (0, 1) для long-only
- barrier_hit: str ('upper', 'lower', 'time')
- holding_period: int
- realized_return: float

**Regression targets:**
- Future returns (на горизонте N)
- Max favorable excursion (MFE)
- Max adverse excursion (MAE)
- Sharpe ratio на скользящем окне

### 2. Постфильтры

**Smoothing:**
- Moving average filter
- Exponential smoothing
- Median filter

**Sequence filter:**
- Минимальная длина последовательности одного класса
- Удаление одиночных сигналов

**Majority vote:**
- Voting по N соседним барам
- Weighted voting

**Danger zones:**
- Фильтрация вокруг экстремальных событий
- Низкая ликвидность
- Высокая волатильность

### 3. Балансировка классов

**Class weights:**
```python
def compute_class_weights(labels: pd.Series, method: str = 'balanced') -> dict:
    """
    Вычислить веса классов
    method: 'balanced', 'effective_samples', 'custom'
    """
```

**Sampling:**
- Random oversampling minority class
- Random undersampling majority class
- SMOTE (для табличных данных, не для sequences)

**Sequence-aware weighting:**
- Веса по длине последовательности
- Веса по близости к текущему времени
- Веса по значимости сделки (PnL)

### 4. Metadata
```python
@dataclass
class LabelingMetadata:
    """Метаданные разметки"""
    labeling_id: str
    method: str  # 'horizon', 'triple_barrier', 'custom'
    config: dict
    dataset_id: str
    total_samples: int
    class_distribution: dict[int, int]
    filters_applied: list[str]
    created_at: datetime
    version: str
```

### 5. Конфигурация
**configs/labeling/long_only.yaml:**
```yaml
method: triple_barrier
params:
  upper_barrier: 0.02  # 2%
  lower_barrier: 0.01  # 1% стоп
  time_barrier: 20
  direction: long

filters:
  - type: smoothing
    params: {window: 3, method: 'median'}

  - type: sequence
    params: {min_length: 2}

  - type: danger_zones
    params: {high_volatility_threshold: 3.0}

balancing:
  method: class_weights
  strategy: balanced
```

### 6. Пайплайн разметки
```python
class LabelingPipeline:
    """Пайплайн генерации и обработки таргетов"""

    def run(self, data: pd.DataFrame, config: dict) -> tuple[pd.DataFrame, LabelingMetadata]:
        """
        1. Генерация сырых labels
        2. Применение постфильтров
        3. Балансировка
        4. Валидация
        5. Сохранение + метаданные
        """
```

## Критерии готовности

- [ ] Horizon labeling работает (fixed + adaptive)
- [ ] Triple barrier реализован корректно
- [ ] Regression targets работают
- [ ] Все постфильтры реализованы
- [ ] Балансировка классов работает
- [ ] Метаданные сохраняются
- [ ] Конфигурация через YAML
- [ ] CLI: `label-dataset`, `analyze-labels`
- [ ] Визуализация распределения классов

## Промпты для реализации

### Промпт 1: Базовые методы разметки
```
Реализуй в src/labeling/:

1. base.py - BaseLabeler абстрактный класс
2. methods/horizon.py - HorizonLabeler (fixed и adaptive)
3. methods/triple_barrier.py - TripleBarrierLabeler

Для triple barrier:
- Векторизованная реализация
- Учёт комиссий (опционально)
- Возврат детальной информации (barrier_hit, holding_period)

Все методы каузальные!
```

### Промпт 2: Regression targets и постфильтры
```
Реализуй:
1. methods/regression_targets.py - future returns, MFE, MAE
2. filters/ - все постфильтры (smoothing, sequence, majority_vote, danger_zones)

Постфильтры должны быть composable (FilterPipeline).
```

### Промпт 3: Балансировка и пайплайн
```
Реализуй:
1. balancing/ - веса, sampling, sequence weighting
2. metadata.py - LabelingMetadata класс
3. src/pipelines/labeling_pipeline.py - LabelingPipeline

Пайплайн должен:
- Быть идемпотентным
- Сохранять метаданные
- Логировать каждый этап
```

### Промпт 4: Визуализация и CLI
```
1. src/labeling/visualization.py:
   - plot_label_distribution()
   - plot_holding_periods()
   - plot_returns_by_label()

2. CLI команды:
   - label_dataset() - разметить
   - analyze_labels() - анализ разметки
   - visualize_labels() - визуализация

Используй matplotlib/plotly для графиков.
```

## Важные замечания

**Triple Barrier:**
- Корректная реализация non-trivial
- Нужно смотреть вперёд для определения когда барьер пробит
- НО сам label не должен использовать будущую информацию для решения

**Балансировка:**
- Для временных рядов oversampling сложнее (нельзя просто дублировать)
- Лучше использовать class weights
- Для sequences - sequence-aware weighting

**Валидация:**
- Проверить что нет look-ahead
- Проверить распределение классов
- Проверить что достаточно примеров каждого класса

**Метаданные:**
- Сохранять всю конфигурацию разметки
- Version control для воспроизводимости

## Следующий этап
[Этап 06: Базовая инфраструктура моделирования](Этап_06_Базовая_инфраструктура_моделирования.md)
