# Этап 18: Распределённые вычисления

## Цель
Реализовать distributed computing: задачи на стационарном ПК, мониторинг с ноутбука.

## Зависимости
Этапы 00-17

## Архитектура

```
Ноутбук (Client)
    ↓ (submit task)
Task Queue (Redis/RabbitMQ)
    ↓ (pull task)
Стационарный ПК (Worker with GPU)
    ↓ (store artifacts)
Shared Storage (artifacts/, MLflow)
    ↑ (fetch results)
Ноутбук (Client)
```

## Компоненты

```
src/distributed/
├── task_queue.py                 # Task queue (Redis)
├── worker.py                     # Worker for desktop PC
├── client.py                     # Client for laptop
├── scheduler.py                  # Task scheduler
├── sync_service.py               # Git sync service
└── failover.py                   # Fallback to local execution
```

## Основные классы

### 1. Task Queue
```python
class TaskQueue:
    """Очередь задач (Redis backend)"""

    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis = redis.from_url(redis_url)

    def submit_task(self, task: Task) -> str:
        """Отправить задачу в очередь"""
        task_id = str(uuid.uuid4())
        self.redis.rpush('tasks', json.dumps({
            'id': task_id,
            'type': task.type,
            'config': task.config,
            'priority': task.priority
        }))
        return task_id

    def get_task_status(self, task_id: str) -> TaskStatus:
        """Статус задачи"""
        return self.redis.get(f'task:{task_id}:status')

    def get_task_result(self, task_id: str) -> Any:
        """Результат задачи"""
        return self.redis.get(f'task:{task_id}:result')
```

### 2. Worker
```python
class Worker:
    """Worker на стационарном ПК"""

    def __init__(self, queue: TaskQueue, device: str = 'gpu'):
        self.queue = queue
        self.device = device

    def run(self):
        """Основной цикл worker"""
        while True:
            task = self.queue.pull_task()
            if task:
                try:
                    result = self.execute_task(task)
                    self.queue.publish_result(task.id, result)
                except Exception as e:
                    self.queue.publish_error(task.id, e)

    def execute_task(self, task: Task):
        """Выполнить задачу"""
        if task.type == 'train_model':
            return self._train_model(task.config)
        elif task.type == 'hyperopt':
            return self._run_hyperopt(task.config)
        elif task.type == 'backtest':
            return self._run_backtest(task.config)
```

### 3. Client
```python
class DistributedClient:
    """Клиент на ноутбуке"""

    def __init__(
        self,
        queue: TaskQueue,
        timeout: int = 3600,
        fallback_local: bool = True
    ):
        self.queue = queue
        self.timeout = timeout
        self.fallback_local = fallback_local

    def submit_training(self, config: dict) -> str:
        """Отправить задачу обучения"""
        task_id = self.queue.submit_task(Task(
            type='train_model',
            config=config
        ))
        return task_id

    def wait_for_result(self, task_id: str) -> Any:
        """Ждать результат"""
        start = time.time()
        while time.time() - start < self.timeout:
            status = self.queue.get_task_status(task_id)

            if status == 'completed':
                return self.queue.get_task_result(task_id)
            elif status == 'failed':
                raise TaskFailedError(task_id)

            time.sleep(5)

        # Timeout - fallback to local if enabled
        if self.fallback_local:
            return self._execute_locally(task_id)
        else:
            raise TimeoutError(task_id)
```

### 4. Git Sync Service
```python
class GitSyncService:
    """Автоматическая синхронизация через Git"""

    def __init__(self, repo_path: Path, branch: str = 'main'):
        self.repo = git.Repo(repo_path)
        self.branch = branch

    def watch_and_pull(self, interval: int = 60):
        """Следить за обновлениями и pull"""
        while True:
            # Fetch remote
            self.repo.remotes.origin.fetch()

            # Check if behind
            if self._is_behind_remote():
                logger.info("New commits detected, pulling...")
                self.repo.git.pull()
                logger.info("Pull completed")

            time.sleep(interval)

    def _is_behind_remote(self) -> bool:
        """Проверить есть ли новые коммиты"""
        local = self.repo.head.commit
        remote = self.repo.remotes.origin.refs[self.branch].commit
        return local != remote
```

### 5. Artifact Sync
```python
class ArtifactSync:
    """Синхронизация артефактов (MLflow, files)"""

    def sync_to_shared_storage(
        self,
        local_path: Path,
        remote_path: str,
        storage_type: str = 's3'
    ):
        """Синхронизировать артефакты в shared storage"""
        if storage_type == 's3':
            # Upload to S3/MinIO
            pass
        elif storage_type == 'network_drive':
            # Copy to network drive
            pass
```

## Deployment

### Docker Compose

**docker-compose.distributed.yml:**
```yaml
version: '3.8'

services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  worker:
    build:
      context: .
      dockerfile: Dockerfile.gpu
    depends_on:
      - redis
    environment:
      - REDIS_URL=redis://redis:6379
      - DEVICE=gpu
    volumes:
      - ./artifacts:/app/artifacts
      - ./configs:/app/configs
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]

volumes:
  redis_data:
```

### Systemd Service (на стационарном ПК)

**trading-worker.service:**
```ini
[Unit]
Description=Trading Platform Worker
After=network.target

[Service]
Type=simple
User=trader
WorkingDirectory=/home/trader/trading-platform
ExecStart=/home/trader/trading-platform/venv/bin/python -m src.distributed.worker
Restart=always

[Install]
WantedBy=multi-user.target
```

**git-sync.service:**
```ini
[Unit]
Description=Git Sync Service
After=network.target

[Service]
Type=simple
User=trader
WorkingDirectory=/home/trader/trading-platform
ExecStart=/home/trader/trading-platform/venv/bin/python -m src.distributed.sync_service
Restart=always

[Install]
WantedBy=multi-user.target
```

## GUI Integration

GUI на ноутбуке показывает:
- Статус worker (online/offline)
- Активные задачи
- Очередь задач
- Результаты (при готовности)

Опция: запустить GUI на стационарном ПК (localhost).

## Критерии готовности

- [ ] Task queue (Redis) работает
- [ ] Worker на desktop PC работает
- [ ] Client на laptop отправляет задачи
- [ ] Git sync service автоматически синхронизирует
- [ ] Artifact sync в shared storage
- [ ] Fallback to local execution
- [ ] Systemd services
- [ ] Мониторинг worker status
- [ ] CLI: `worker start/stop/status`, `task submit/status`

## Промпты

```
Реализуй distributed computing в src/distributed/:

1. task_queue.py - TaskQueue (Redis backend)
2. worker.py - Worker с event loop
3. client.py - DistributedClient
4. sync_service.py - GitSyncService
5. failover.py - Fallback логика

Создай systemd services:
- scripts/systemd/trading-worker.service
- scripts/systemd/git-sync.service

CLI команды в src/interfaces/cli/distributed_commands.py:
- worker start/stop/status
- task submit/status/cancel
- sync status

Docker compose для distributed setup.
```

## Важные замечания

**Network:**
- Ноутбук и ПК должны быть в одной сети
- Или VPN для remote access
- Или cloud Redis

**Shared Storage:**
- Network drive
- S3/MinIO
- Rsync

**Security:**
- Redis authentication
- Encrypted connections
- Firewall rules

**Monitoring:**
- Worker health checks
- Task queue depth
- Artifact sync status

## Следующий этап
[Этап 19: CI/CD и тестирование](Этап_19_CI_CD_и_тестирование.md)
